import com.example.prices.*;
import io.grpc.stub.StreamObserver;

import java.time.LocalDate;
import java.time.YearMonth;
import java.util.*;
import java.util.concurrent.*;

public class PriceServiceImpl extends PriceServiceGrpc.PriceServiceImplBase {

    private final ExecutorService requestExecutor;      // injected for top-level request concurrency
    private final ExecutorService datastoreExecutor;    // 2-thread executor for datastore
    private final PriceCache priceCache;
    private final SymbolPool symbolPool;
    private final BulkLoader bulkLoader;

    public PriceServiceImpl(
            ExecutorService requestExecutor,
            PriceCache priceCache,
            SymbolPool symbolPool,
            BulkLoader bulkLoader) {

        this.requestExecutor = requestExecutor;
        this.priceCache = priceCache;
        this.symbolPool = symbolPool;
        this.bulkLoader = bulkLoader;
        this.datastoreExecutor = Executors.newFixedThreadPool(2); // datastore rate limit
    }

    @Override
    public void getPrices(PriceIntervalRequest request, StreamObserver<PriceBatchResponse> responseObserver) {
        // Submit the request to the top-level executor
        requestExecutor.submit(() -> processRequest(request, responseObserver));
    }

    private void processRequest(PriceIntervalRequest request, StreamObserver<PriceBatchResponse> responseObserver) {
        try {
            LocalDate start = LocalDate.parse(request.getStartDate());
            LocalDate end = LocalDate.parse(request.getEndDate());
            List<String> symbols = request.getSymbolIdsList();
            int batchSize = 1000;

            List<YearMonth> months = splitMonths(start, end);

            for (YearMonth ym : months) {
                LocalDate monthStart = ym.atDay(1);
                LocalDate monthEnd = ym.atEndOfMonth();
                LocalDate from = monthStart.isBefore(start) ? start : monthStart;
                LocalDate to = monthEnd.isAfter(end) ? end : monthEnd;

                for (int i = 0; i < symbols.size(); i += batchSize) {
                    List<String> batch = symbols.subList(i, Math.min(i + batchSize, symbols.size()));
                    processBatchMonth(batch, ym, from, to, responseObserver);
                }
            }

            responseObserver.onCompleted();
        } catch (Exception e) {
            responseObserver.onError(e);
        }
    }

    private void processBatchMonth(
            List<String> symbols,
            YearMonth ym,
            LocalDate from,
            LocalDate to,
            StreamObserver<PriceBatchResponse> responseObserver) {

        Map<String, double[]> hits = new HashMap<>();
        List<String> misses = new ArrayList<>();

        // Check cache
        for (String sym : symbols) {
            String canonical = symbolPool.getCanonical(sym);
            double[] monthPrices = priceCache.get(canonical, ym);
            if (monthPrices != null) hits.put(canonical, monthPrices);
            else misses.add(canonical);
        }

        PriceBatchResponse.Builder respBuilder = PriceBatchResponse.newBuilder().setYearMonth(ym.toString());

        // Add cache hits
        for (Map.Entry<String, double[]> e : hits.entrySet()) {
            SymbolPrices.Builder spb = SymbolPrices.newBuilder().setSymbolId(e.getKey());
            double[] arr = e.getValue();
            int fromIdx = from.getDayOfMonth() - 1;
            int toIdx = to.getDayOfMonth() - 1;
            for (int d = fromIdx; d <= toIdx; d++) spb.addPrices(arr[d]);
            respBuilder.addSymbols(spb);
        }

        if (misses.isEmpty()) {
            responseObserver.onNext(respBuilder.build());
            return;
        }

        // Async datastore load (rate-limited, 2 threads)
        CompletableFuture
                .supplyAsync(() -> bulkLoader.loadMonthPrices(misses, ym), datastoreExecutor)
                .thenAccept(resultMap -> {
                    for (Map.Entry<String, double[]> e : resultMap.entrySet()) {
                        priceCache.put(e.getKey(), ym, e.getValue());
                        SymbolPrices.Builder spb = SymbolPrices.newBuilder().setSymbolId(e.getKey());
                        double[] arr = e.getValue();
                        int fromIdx = from.getDayOfMonth() - 1;
                        int toIdx = to.getDayOfMonth() - 1;
                        for (int d = fromIdx; d <= toIdx; d++) spb.addPrices(arr[d]);
                        respBuilder.addSymbols(spb);
                    }
                    responseObserver.onNext(respBuilder.build());
                })
                .exceptionally(ex -> {
                    responseObserver.onError(ex);
                    return null;
                });
    }

    // Utility to split interval into months
    private static List<YearMonth> splitMonths(LocalDate start, LocalDate end) {
        List<YearMonth> months = new ArrayList<>();
        if (start.isAfter(end)) return months;

        YearMonth cursor = YearMonth.from(start);
        YearMonth endYm = YearMonth.from(end);
        while (!cursor.isAfter(endYm)) {
            months.add(cursor);
            cursor = cursor.plusMonths(1);
        }
        return months;
    }
}


///////////
/////////
//////////

import java.util.concurrent.*;

public class PriceServerMain {
    public static void main(String[] args) {
        ExecutorService requestExecutor = new ThreadPoolExecutor(
                10, 10,
                0L, TimeUnit.MILLISECONDS,
                new ArrayBlockingQueue<>(50),
                new ThreadPoolExecutor.AbortPolicy()
        );

        SymbolPool symbolPool = new SymbolPool(100_000);
        PriceCache priceCache = new PriceCache(symbolPool);
        BulkLoader bulkLoader = new BulkLoader();

        PriceServiceImpl service = new PriceServiceImpl(requestExecutor, priceCache, symbolPool, bulkLoader);

        // gRPC server initialization
        // ServerBuilder.forPort(9090).addService(service).build().start();
    }
}


/////////////
///////////
////////////

import java.time.YearMonth;
import java.util.*;
import java.util.concurrent.ThreadLocalRandom;

public class BulkLoader {

    public Map<String, double[]> loadMonthPrices(List<String> symbols, YearMonth ym) {
        Map<String, double[]> result = new HashMap<>();
        int attempts = 0;
        int maxAttempts = 5;
        int daysInMonth = ym.lengthOfMonth();

        while (attempts < maxAttempts) {
            attempts++;
            try {
                // simulate 429 rate limit
                if (ThreadLocalRandom.current().nextInt(10) < 2) {
                    throw new RateLimitException("429 Too Many Requests");
                }

                for (String sym : symbols) {
                    double[] arr = new double[daysInMonth];
                    for (int i = 0; i < daysInMonth; i++) {
                        arr[i] = ThreadLocalRandom.current().nextDouble(100, 200);
                    }
                    result.put(sym, arr);
                }

                return result;

            } catch (RateLimitException e) {
                try {
                    Thread.sleep((long) Math.pow(2, attempts) * 100L);
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    throw new RuntimeException("Interrupted during backoff", ie);
                }
            }
        }
        throw new RuntimeException("Failed after retries");
    }

    private static class RateLimitException extends RuntimeException {
        RateLimitException(String msg) { super(msg); }
    }
}


/////////////
////////////
/////////////

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;

import java.time.Duration;
import java.time.YearMonth;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Month-level cache for symbol prices.
 * Key: YearMonth
 * Value: Map of canonical symbol -> daily prices array (double[])
 */
public class PriceCache {

    private final Cache<YearMonth, Map<String, double[]>> cache;
    private final SymbolPool symbolPool;

    public PriceCache(SymbolPool symbolPool) {
        this.symbolPool = symbolPool;
        this.cache = Caffeine.newBuilder()
                .maximumSize(50_000)           // adjust for max YearMonth keys
                .expireAfterWrite(Duration.ofHours(6))
                .build();
    }

    /**
     * Retrieve cached prices for a symbol in a given month.
     * Returns null if not in cache.
     */
    public double[] get(String symbol, YearMonth ym) {
        String canonical = symbolPool.getCanonical(symbol);
        Map<String, double[]> monthMap = cache.getIfPresent(ym);
        return (monthMap != null) ? monthMap.get(canonical) : null;
    }

    /**
     * Put prices for a symbol/month into the cache.
     * Thread-safe via ConcurrentHashMap.
     */
    public void put(String symbol, YearMonth ym, double[] prices) {
        String canonical = symbolPool.getCanonical(symbol);
        Map<String, double[]> monthMap = cache.get(ym, k -> new ConcurrentHashMap<>());
        monthMap.put(canonical, prices);
    }

    /**
     * Check if cache contains prices for a symbol/month.
     */
    public boolean contains(String symbol, YearMonth ym) {
        String canonical = symbolPool.getCanonical(symbol);
        Map<String, double[]> monthMap = cache.getIfPresent(ym);
        return monthMap != null && monthMap.containsKey(canonical);
    }

    /**
     * Optional: Clear the cache (for testing or maintenance)
     */
    public void clear() {
        cache.invalidateAll();
    }
}


///////////
////////
////////////


import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;

import java.util.concurrent.TimeUnit;

/**
 * Canonical symbol pool to deduplicate symbol strings and limit memory.
 * Max size is fixed; old/unused symbols are evicted automatically.
 */
public class SymbolCache {

    private final Cache<String, String> pool;

    /**
     * @param maxSize Maximum number of unique symbols to store
     */
    public SymbolCache(int maxSize) {
        this.pool = Caffeine.newBuilder()
                .maximumSize(maxSize)
                .expireAfterAccess(24, TimeUnit.HOURS) // optional eviction policy
                .build();
    }

    /**
     * Returns a canonical string for the symbol.
     * If symbol already exists in cache, returns existing reference.
     * Otherwise, inserts and returns it.
     */
    public String getCanonical(String symbol) {
        return pool.get(symbol, s -> s);
    }

    /**
     * Optional: remove a symbol from pool
     */
    public void remove(String symbol) {
        pool.invalidate(symbol);
    }

    /**
     * Optional: clear all cached symbols
     */
    public void clear() {
        pool.invalidateAll();
    }
}
